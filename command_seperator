#include "shell.h"

/**
* cmd_seperator - this function handles the logic of command seperators
* @get_line_val: this the text read from standard input to be tokenized.
* @currt_wrk_dir: this is the current working directory of the shell.
* @user_prompt: this is the user prompt for the shell.
* Return: void
*/

void cmd_seperator(char *get_line_val, char *currt_wrk_dir, char *user_prompt);

void cmd_seperator(char *get_line_val, char *currt_wrk_dir, char *user_prompt)
{

	int arg_idx = 0;

	char *ldb_token;

	char *cmd;

	char **ldb_cmd_args;

	int ln = 0;

	(void)user_prompt;

	ldb_token = ldb_strtok(get_line_val, ";");

	while (ldb_token != NULL && arg_idx < MAX_ARGS)
	{
		cmd = ldb_token;

		/*Check number of commands entered seprated by space or tab*/
		while (*cmd == ' ' || *cmd == '\t')
		{
			/*Increament the number of commands count*/

			cmd += 1;
		}

		ln = strlen(cmd);

		while (ln > 0 && (cmd[ln - 1] == ' ' || cmd[ln - 1] == '\t'))
		{
			ln -= 1;
		}
		cmd[ln] = '\0'; /*I null terminated the command array*/

	/*Allocate memory for the command line arguments and execute*/

		ldb_cmd_args = malloc(sizeof(char *) * (MAX_ARGS + 1));

		if (ldb_cmd_args == NULL)
		{
			perror("Memory Allocation Failed");
			exit(EXIT_FAILURE);
		}

		arg_idx = 0; /*I update the value of index to 0*/

		ldb_token = ldb_strtok(cmd, " \t\n");

		while (ldb_token != NULL && arg_idx < MAX_ARGS)
		{
			/*Populate the allocated memory*/
			ldb_cmd_args[arg_idx] = ldb_token;

			ldb_token++;

			ldb_token = ldb_strtok(NULL, " \t\n");
		}
		ldb_cmd_args[arg_idx] = NULL; /*Null terminate the array*/

		if (arg_idx > 0)
		{
			if (strcmp(ldb_cmd_args[0], "exit") == 0)
			{
				free(ldb_cmd_args);
				exit(EXIT_SUCCESS);
			}
			else if (strcmp(ldb_cmd_args[0], "env") == 0)
			{
				char **env;

				for (env = environ; *env != NULL; env++)
				{
					_printf("%s\n", *env);
				}
			}
			else if (strcmp(ldb_cmd_args[0], "cd") == 0)
			{
				change_dir(ldb_cmd_args, currt_wrk_dir);
			}
			else
			{

			/*Validate executable file before calling execve*/
				if (strchr(ldb_cmd_args[0], '/') != NULL)
				{
					if (access(ldb_cmd_args[0], X_OK) != -1)
					{
						call_and_execute(ldb_cmd_args);
					}
					else
					{
						_printf("bash: %s: No such file or directory\n", ldb_cmd_args[0]);
					}
				}
				else /*USer enterd the file name*/
				{
					char *file_path = "/bin/";

					char exec_file[MAX_INPUT_SIZE];

					strcpy(exec_file, file_path);
					strcat(exec_file, ldb_cmd_args[0]);
					if (access(exec_file, X_OK) != -1)
					{
						call_and_execute(ldb_cmd_args);
					}
					else
					{
						_printf("bash: %s: No such file or directory", exec_file);
					}
				}
			}
		}
	/*End of (if arg_idx > 0)*/
		free(ldb_cmd_args);

		ldb_token = ldb_strtok(NULL, ";");
	}
/*End of while loop*/

}
